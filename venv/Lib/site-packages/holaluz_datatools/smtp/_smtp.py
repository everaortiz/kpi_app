import os
import logging
import smtplib
import ssl
from email import encoders
from email.utils import formataddr, formatdate
from email.mime.base import MIMEBase
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart

SSL_PORT = 465
SMTP_HOST = "smtp.gmail.com"

logger = logging.getLogger(__name__)

def _format_receiver_addresses(addresses):
    """helper function to format the receiver addresses"""
    if isinstance(addresses, str):
        # we do not check the str integrity
        return addresses
    else: # assume iterable-like
        return ', '.join(addresses)

def _encode_file(attachment):
    """helper function to encode a local file, as a processing step before attaching it to an email"""
    if isinstance(attachment, dict):
        filepath, filename = list(attachment.items())[0]
    else: # assume str:
        filepath, filename = attachment, os.path.basename(attachment)
        
    msg_file = MIMEBase('application', 'octet-stream')
    with open(filepath, 'rb') as fin:
        msg_file.set_payload(fin.read())
        
    encoders.encode_base64(msg_file)
    msg_file.add_header(
        'Content-Disposition', 
        f'attachment; filename="{os.path.basename(filename)}"'
    )
    
    logger.debug(f'attached {filepath} to message as {filename}')
    
    return msg_file
    
def _generate_message(
    sender_email, 
    receiver_emails, 
    cc_receiver_emails,
    bcc_receiver_emails,
    subject,
    email_body,
    attachments
):
    """helper function to generate the message object to be sent"""    
    msg = MIMEMultipart()
    msg['From'] = sender_email
    logger.debug(f'added {sender_email} as sender email address')
    
    receiver_emails = _format_receiver_addresses(receiver_emails)
    msg['To'] = receiver_emails
    logger.debug(f'added {receiver_emails} as receiver email address(es)')
    
    msg['Subject'] = subject
    msg['Date'] = formatdate(localtime = True)
    msg.attach(MIMEText(email_body, 'html'))
    
    if cc_receiver_emails is not None:
        cc_receiver_emails = _format_receiver_addresses(cc_receiver_emails)
        msg['Cc'] = cc_receiver_emails
        logger.debug(f'added {cc_receiver_emails} as CC receiver email address(es)')
        
    if bcc_receiver_emails is not None:
        bcc_receiver_emails = _format_receiver_addresses(bcc_receiver_emails)
        msg['Bcc'] = bcc_receiver_emails
        logger.debug(f'added {bcc_receiver_emails} as BCC receiver email address(es)')
        
    if attachments is not None:
        if isinstance(attachments, (str, dict)):
            attachments = [attachments]
           
        for attachment in attachments:
            msg.attach(_encode_file(attachment))
            
    return msg
    
def send_email(
    sender_email, 
    sender_password,
    receiver_emails,
    sender_alias = None,
    cc_receiver_emails = None,
    bcc_receiver_emails = None,
    subject = '', 
    email_body = '', 
    attachments = None
):
    """
    Function to send emails via Gmail and Python, that uses the 
    `smtplib` and `email` built-in packages under the hood. 
    It allows to send messages using aliases (if they are correctly
    configured in your account), and to attach a wide variety of
    files (such as Excel, CVS, JSON, JPG, IPYNB...).
    
    Parameters
    ----------
    sender_email: str
        the sender email with which to login
    sender_password: str
        the sender email app password
        NOTE: to set up the app password for your account
              check the following link
              https://support.google.com/accounts/answer/185833
    receiver_emails: str or list
        the address(es) that will recieve the email. it can be
        either a single email address or comma-separated addresses
        as a string or a list of addresses
    sender_alias: str, optional
        alias account with which the email is sent.
        NOTE: to set up an alias, check the following link
              https://support.google.com/accounts/answer/33327
    cc_receiver_emails: str or list, optional
        cc receiver emails. formatted as `receiver_emails`
    bcc_receiver_emails: str or list, optional
        bcc receiver emails. formatted as `receiver_emails`
    subject: str, optional
        the message subject
    email_body: str, optional 
        the email body, which can be either HTML or plain text
    attachments: str, dict, list[str] or list[dict], optional
        path to local files to attach. if
        - dict or list[dict]: the key must the the local filepath
                              and the value the name of the file
                              attached
        - str or list[str]: just the local filepath, and the name
                            of the file attached is the same as the
                            one of the local file.
    """
    msg = _generate_message(
        sender_email = sender_alias or sender_email,  
        receiver_emails = receiver_emails,
        cc_receiver_emails = cc_receiver_emails,
        bcc_receiver_emails = bcc_receiver_emails,
        subject = subject, 
        email_body = email_body, 
        attachments = attachments
    )
    
    context = ssl.create_default_context()
    with smtplib.SMTP_SSL(SMTP_HOST, SSL_PORT, context = context) as server:
        server.login(sender_email, sender_password)
        server.send_message(msg)
    
    logger.info('email sent successfully')