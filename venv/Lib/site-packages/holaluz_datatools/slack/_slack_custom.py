from audioop import add
from slack_sdk import WebClient
from slack_sdk.errors import SlackApiError
from datetime import datetime
import logging
import traceback


SLACK_BI_INTEGRATOR_CHANNEL = '#bi-integrator-python-scripts-log'
SLACK_BI_INTEGRATOR_DATA_QUALITY_CHANNEL = '#data-quality-alerts'
SLACK_BI_INTEGRATOR_JOHN_SNOW = '#john-snow-ofertas'
SLACK_SOLAR_BOT_CHANNEL = '#solar-python-scripts-log'

ERROR_LOG_FORMATABLE_FILENAME = 'error_log_{}_{}.txt'
ERROR_LOG_DATETIME_FORMAT = '%Y%m%d_%H%M%S'

DEFAULT_NAMES_TO_LINK = ['channel']
DEFAULT_MSG_EMOJI = ':warning:'

logger = logging.getLogger(__name__)

def _format_names_to_link(names_to_link):
    """helper function that formats the given names to link when sending a message"""
    formatted_names_to_link = []
    for name in names_to_link:
        formatted_name = name.lower().replace(' ', '.')
        formatted_name = f'@{formatted_name}' if not formatted_name.startswith('@') else formatted_name
        formatted_names_to_link += [formatted_name]

    return formatted_names_to_link
    

def send_message_by_slack(
    message, 
    creds, 
    script_name, 
    channel = SLACK_BI_INTEGRATOR_CHANNEL,
    link_names = True,
    names_to_link = None,
    add_emoji = None,
    verbose = True
):
    """
    If the script `script_name` fails, it sends an error message `message` to the channel `channel`.
    If the message can't be sent, it creates a file with the error message on the script folder

    Parameters
    ----------
    message: str
        the error mesage to be send
    creds: dict
        slack API credentials, i.e., the API 
        token for the slack client as a dict
        `{'token': <api_key>}`
    script_name: str
        name of the script being executed
    channel: str, optional
        the channel where the message is sent
    link_names: bool, optional
        whether to tag users with `@` or not
    names_to_link: str or list, optional
        names to tag in the message; only used
        if `link_names` is True.
        if it is a str, we pass it as a list
        under the hood. moreover, we format the
        given names to match the slack user names
        in the Holaluz Slack workspace
    add_emoji: bool, optional
        if True, it pre-prends `DEFAULT_MSG_EMOJI`
        to the given message; if None, takes the 
        same value as `link_names`
    verbose: bool, optional
        whether to print log messages or not
    """
    client = WebClient(**creds)
    
    msg_prefix = DEFAULT_MSG_EMOJI if (add_emoji or link_names) else ''
    if link_names:
        names_to_link = [names_to_link] if isinstance(names_to_link, str) else names_to_link
        names_str = ', '.join(_format_names_to_link(names_to_link or DEFAULT_NAMES_TO_LINK))
        message = f'{msg_prefix} {names_str}\n{message}'.strip()
    else:
        message = f'{msg_prefix}\n{message}'.strip()

    try:
        client.chat_postMessage(channel = channel, text = message, link_names = int(link_names))
    except SlackApiError as sae:
        error_log_file_message = (
            f'Unable to send error log for the script {script_name!r} '
            f'due to the following error: {sae.response["error"]!r}\n'
        ) + message
        error_log_filename = ERROR_LOG_FORMATABLE_FILENAME.format(
            script_name, 
            datetime.now().strftime(ERROR_LOG_DATETIME_FORMAT)
        )
        with open(error_log_filename, 'w') as fout:
            fout.write(error_log_file_message)
    else:
        # link names (tag people) only with error messages
        if verbose:
            if link_names:
                logger.error(
                    f'{script_name!r} execution error log send by '
                    f'Slack to channel {channel!r}\n'
                )
            else:
                logger.warning(
                    f'{script_name!r} execution error log send by '
                    f'Slack to channel {channel!r}\n'
                )

def send_file_by_slack(
    filepath, 
    message, 
    creds, 
    script_name, 
    channel = SLACK_BI_INTEGRATOR_CHANNEL, 
    link_names = 1,
    verbose = True
):
    """
    Sends a file generated by the script `script_name` fails, with an additional message `message`,
    to the channel `channel`.
    If the file can't be sent, it sends a message warning about it.

    Parameters
    ----------
    filepath: str
        the (path and) file to send
    message: str
        the mesage to send alogn witht he file
    creds: dict
        slack API credentials, i.e., the API token for the slack client
    script_name: str
        name of the script being executed
    channel: str, optional
        the channel where the message is sent
    link_names: int, optional
        whether to tag users with `@` or not
        use 1 to do so, 0 otherwise
    verbose: bool, optional
        whether to print log messages or not
    """
    client = WebClient(**creds)
    message_with_emoji = ':warning: @channel \n' + message
    try:
        client.files_upload(
            file = filepath,
            initial_comment = message_with_emoji,
            channels = channel,
        )
    except SlackApiError as sae:
        error_log_file_message = (
            f'Unable to send error log file {filepath!r} for the script {script_name!r} '
            f'due to the following error: {sae.response["error"]!r}\n'
        )
        if verbose:
            logger.error(error_log_file_message)
        send_message_by_slack(error_log_file_message, creds, script_name, channel, link_names)
    else:
        if verbose:
            logger.info(
                f'log file {filepath!r} for the script {script_name!r} successfully send '
                f'to channel {channel!r}'
            )

def run_or_send_log_error(function, script_name, credentials, logger_level = logging.INFO, channel = SLACK_BI_INTEGRATOR_CHANNEL, **f_kwargs):
    """
    Run the function `function` from the script `script_name`. If the script fails, 
    it sends an error message by calling `send_message_by_slack`, see its docs for
    further info

    Note that this function has the same effect as `_decorators.run_or_send_log_error`
    but has differents arguments

    Parameters
    ----------
    function: 
        pointer to the function to be executed, i.e., must be passed without parenthesis
    script_name: str
        name of the script where the function comes from
    credentials: dict
        credentials for the slack bot
    logger_level: int [DEPRECATED]
        level of the logger. one of `logging.DEBUG`, `logging.INFO`, `logging.WARNING`, 
        `logging.ERROR`, `logging.CRITICAL`, or any custom level one may use
    **f_kwargs
        additional arguments passed to `function`
    """
    try:
        logger.info(f"Starting the execution of '{script_name}'")
        function(**f_kwargs)
    except Exception as e:
        traceback_message = '\n'.join(traceback.format_tb(e.__traceback__))
        error_message = (
            f"Unable to execute the script `{script_name}` due to the following error:\n"
            f"```{traceback_message}\n{type(e).__name__}: {e}```"
        )
        send_message_by_slack(error_message, credentials, script_name, channel = channel)
    else:
        logger.info(f"'{script_name}' executed successfully\n")