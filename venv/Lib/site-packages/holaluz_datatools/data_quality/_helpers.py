import os
import sys
import yaml
import logging

from ..utils import search_fp_obj

# these first two are fixed according to great_expectations
GREAT_EXPECTATIONS_DIR = 'great_expectations'
GREAT_EXPECTATIONS_PLUGIN_DIR = 'plugins'

DATA_QUALITY_DIR = 'data_quality'
DATA_QUALITY_DIR_NAME = 'data quality folder'

CUSTOM_EXPECTATIONS_DIR = 'expectations'
CUSTOM_EXPECTATIONS_DIR_NAME = 'custom expectations folder'

GE_YML_FILE = 'great_expectations_{environment}.yml'
GE_YML_FILE_NAME = 'context YAML file'

DATA_QUALITY_EXPECTATIONS_FILE_FOLDER_NAME = 'data quality expectations YAML file folder'
DATA_QUALITY_EXPECTATIONS_FILE_NAME = 'data quality expectations YAML file'

if 'USERPROFILE' in os.environ: # Windows
    USER_PATH = os.path.realpath(
        os.path.join(os.environ['USERPROFILE'], 'Documents')
    )
else: # Linux / macOS
    USER_PATH = os.path.realpath(os.environ['HOME'])

REPO_PATH = os.path.realpath(
    os.path.join(USER_PATH, 'GitHub', 'bi-integrator')
)
SEARCH_START_DIRS = [
    # absolute path to the script folder, or `-c` if executed as so
    os.path.abspath(os.path.dirname(sys.argv[0])),
    # absolute path to the module being imported; depending on the 
    # interpreter this might be the same as the first option
    os.path.abspath(os.path.dirname(__file__)), 
    # deterministic and opinionated path, as most scripts will be in this repo
    REPO_PATH, 
    # long shot, probably only useful if ran manually from the command line
    os.getcwd() 
]

ACCEPTED_EXPECTATIONS_KEYS = ['critical_expectations', 'warning_expectations']

logger = logging.getLogger(__name__)

def find_context_yml_file(environment, search_start_dir = None, n_layers = 5):
        """
        Search for the environment YAML config file, starting in
        `search_start_dir` and moving upward, up to `n_layers` times.
        """
        ge_yml_fp = os.path.join(
            DATA_QUALITY_DIR, 
            GREAT_EXPECTATIONS_DIR, 
            GE_YML_FILE.format(environment = environment)
        )
        search_paths = [search_start_dir] if search_start_dir is not None else SEARCH_START_DIRS
        return search_fp_obj(
            target_fp_obj = ge_yml_fp, 
            search_paths = search_paths, 
            target_fp_obj_name = GE_YML_FILE_NAME, 
            n_levels = n_layers
        )

def snake_case_to_pascal_case(snake_case_string):
    """
    helper function that converts a snake case string  (i.e., a string formatted
    as `this_is_a_snake_cased_string`) into its corresponding pascal case string 
    (i.e., `ThisIsACamelCasedString`)
    """
    return snake_case_string.title().replace('_', '')

def load_custom_expectations(search_start_dir = None, n_layers = 5, custom_expectations_dir = CUSTOM_EXPECTATIONS_DIR):
    """
    Loads custom (user-defined) expectations to be later used when performing data quality checks.
    If this function is invoked directly, make sure you have loaded the GE context file previously.

    Parameters
    ----------
    search_start_dir: str, optional
        path where where `search_fp_obj` starts to search for the root data
        quality folder
    n_layers: int, optional
        number of layers where `search_fp_obj` searches for the data quality
        folder. only used if `search_start_dir` is `None`
    custom_expectations_dir: str, optional
        name of the folder where the custom expectations are located
    """
    custom_expectations_sufix = os.path.join(
        DATA_QUALITY_DIR,
        GREAT_EXPECTATIONS_DIR, 
        GREAT_EXPECTATIONS_PLUGIN_DIR,
        custom_expectations_dir
    )
    search_paths = [search_start_dir] if search_start_dir is not None else SEARCH_START_DIRS
    custom_expectations_path = search_fp_obj(
        target_fp_obj = custom_expectations_sufix, 
        search_paths = search_paths, 
        target_fp_obj_name = CUSTOM_EXPECTATIONS_DIR_NAME, 
        n_levels = n_layers
    )
    
    for module in os.listdir(custom_expectations_path):
        if module.endswith('.py'):
            module_name, _ = os.path.splitext(module)
            # according to great_expectations naming conventions,
            # the module name is formatted as `expect_something`
            # and the class (expectation) name as `ExpectSomething`
            class_name = snake_case_to_pascal_case(module_name)
            exec(f'from {custom_expectations_dir}.{module_name} import {class_name}')

def dump_expectations_file(expectations, expectations_file, base_path = None, n_layers = 5):
    """
    Dumps the given expectations into a YAML file so it can be read
    later on when calling `check_data_quaility` in the ETL scripts.
    
    Parameters
    ----------
    expectations: dict
        expectations to be dumped. see the usage example below
    expectations_file: str
        name of the expectations file, that can optionally contain
        a path part too.
        NOTE: the actual filepath to the expectations file is built
        as `os.path.join(base_path, expectations_file)`
    base_path: str, optional
        path where the expectations file is saved. If None, it is
        determined using `search_fp_obj`
    n_layers: int, optional
        number of layers where `search_fp_obj` searches for a
        data quality folder. only used if `base_path` is `None`
    
    Usage example
    -------------
    crit_expectation_1 = {
        'expectation_type': 'expect_column_values_to_not_be_null',
        'kwargs': {
            'column': 'some_pk_column',
            'mostly': 1.0,
            'result_format': 'COMPLETE'
        },
    }
    warn_expectation_1 = {
        'expectation_type': 'expect_column_distinct_values_to_be_in_set',
        'kwargs': {
            'column': 'some_other_column',
            'value_set': list(range(1, 11)),
            'result_format': 'BASIC'
        },
    }
    expectations = {
        'critical_expectations': [crit_expectation_1]
        'warning_expectations': [warn_expectation_1]
    }
    expectations_file = 'expectation_files/demo/demo_expectations.yml'
    base_path = '.'
    
    dump_expectations(expectations, expectations_file, base_path)
    """
    if any(key not in ACCEPTED_EXPECTATIONS_KEYS for key in expectations):
        raise ValueError(
            f'the keys of the expectations object must belong '
            f'to {ACCEPTED_EXPECTATIONS_KEYS} but you passed '
            f'{list(expectations)}'        
        )

    expectations_partial_path, expectations_file = os.path.split(expectations_file)
    search_paths = [base_path] if base_path is not None else SEARCH_START_DIRS

    try:
        expectations_full_path = search_fp_obj(
            target_fp_obj = expectations_partial_path, 
            search_paths = search_paths, 
            target_fp_obj_name = DATA_QUALITY_EXPECTATIONS_FILE_FOLDER_NAME, 
            n_levels = n_layers
        )
    except:
        logger.error(
            f'unable to find the folder where the expectations files are stored '
            f'{expectations_partial_path!r}. have you created already?'
        )
        raise
    else:
        expectations_fp = os.path.join(expectations_full_path, expectations_file)
        with open(expectations_fp, 'w') as f_out:
            yaml.safe_dump(expectations, f_out)

        logger.info(f'dumped the given expectations to {expectations_fp}')
    
def load_expectations_file(expectations_file, base_path = None, n_layers = 5):
    """
    Loads the expectations from a YAML file.
    
    Parameters
    ----------
    expectations_file: str
        name of the expectations file, that can optionally contain
        a path part too.
        NOTE: the actual filepath to the expectations file is built
        as `os.path.join(base_path, expectations_file)`
    base_path: str, optional
        path where the expectations file is located. If None, it is
        determined using `search_fp_obj`
    n_layers: int, optional
        number of layers where `search_fp_obj` searches for a
        data quality folder. only used if `base_path` is `None`
    
    Returns
    -------
    expectations: dict
        the expectations loaded from the YAML expectations file
    """
    search_paths = [base_path] if base_path is not None else SEARCH_START_DIRS
    expectations_fp = search_fp_obj(
        target_fp_obj = expectations_file, 
        search_paths = search_paths, 
        target_fp_obj_name = DATA_QUALITY_EXPECTATIONS_FILE_NAME, 
        n_levels = n_layers
    )

    with open(expectations_fp, 'r') as f_in:
        expectations = yaml.safe_load(f_in)
    
    logger.info(f'loaded expectations from {expectations_fp}')
    
    if any(key not in ACCEPTED_EXPECTATIONS_KEYS for key in expectations):
        raise ValueError(
            f'the keys of the expectations object must belong '
            f'to {ACCEPTED_EXPECTATIONS_KEYS} but the loaded file '
            f'have {list(expectations)}. did you created it using '
            f'`dump_expectations`?'
        )
        
    return expectations