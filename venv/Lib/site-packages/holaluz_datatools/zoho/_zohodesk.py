import requests
import time
import traceback
import logging
import functools
import json

AUTH_BASE_URL = 'https://accounts.zoho.com'
AUTH_TOKEN_ENDPOINT = '/oauth/v2/token'
DEFAULT_AUTH_TOKEN_EXPIRATION_TIME = 3600

DESK_BASE_URL = 'https://desk.zoho.com'

DESK_GET_TICKET_ENDPOINT = '/api/v1/tickets/{ticket_id}'                        # GET
DESK_GET_TICKET_HISTORY_ENDPOINT = '/api/v1/tickets/{ticket_id}/History'
DESK_GET_ALL_TICKETS_ENDPOINT = '/api/v1/tickets'
DESK_GET_ALL_ASSOCIATED_TICKETS_ENDPOINT = '/api/v1/associatedTickets'
DESK_UPDATE_TICKET_ENDPOINT = '/api/v1/tickets/{ticket_id}'                     # PATCH
DESK_BULK_UPDATE_TICKETS_ENDPOINT = '/api/v1/tickets/updateMany'                # POST

DESK_SEARCH_TICKETS_ENDPOINT = '/api/v1/tickets/search'                         # GET

DESK_GET_THREAD_ENDPOINT = '/api/v1/tickets/{ticket_id}/threads/{thread_id}'    # GET
DESK_GET_LATEST_THREAD_ENDPOINT = '/api/v1/tickets/{ticket_id}/latestThread'
DESK_GET_ALL_THREADS_ENDPOINT = '/api/v1/tickets/{ticket_id}/threads'

DESK_MAX_TICKETS = 100              # max tickets in one get all tickets request
DESK_MAX_TICKETS_EVENTS = 50        # max events in one ticket history request
DESK_MAX_ASSOCIATED_TICKETS = 100   # max ticket in one associated ticket request
DESK_MAX_TICKETS_THREADS = 200      # max threads in one list threads request
DESK_MAX_TICKETS_SEARCH = 100       # max tickets in one search request

DESK_SEARCH_TICKETS_DATETIME_FORMAT = '%Y-%m-%dT%H:%M:%S.%f'

logger = logging.getLogger(__name__)

def refresh_token(func):
    """
    Decorator to refresh the session token, if necessary, when `func` makes 
    requests to an API.
    """
    @functools.wraps(func)
    def wrapper(cls, *args, **kwargs):
        if hasattr(cls, '_token_expiration_time') and time.time() > cls._token_expiration_time:
            logger.debug('refreshing session token')
            cls._set_or_update_desk_requests_headers()
        return func(cls, *args, **kwargs)

    return wrapper

class ZohoDeskClient:
    """
    Class to interact with several endpoints of the Zoho Desk API.
    """
    def __init__(self, client_id, client_secret, refresh_token, session_request_count = 0):
        """
        Parameters
        ----------
        client_id: str
            Zoho Desk API client ID
        client_secret: str
            Zoho Desk API client secret
        refresh_token: str
            Zoho Desk API refresh token, used to
            authenticate requests
        session_request_count: int, optional
            count of the current session requests
        """
        self._client_id = client_id
        self._client_secret = client_secret
        self._refresh_token = refresh_token
                
        self.max_tickets = DESK_MAX_TICKETS
        self.max_tickets_events = DESK_MAX_TICKETS_EVENTS
        self.max_associated_tickets = DESK_MAX_ASSOCIATED_TICKETS
        self.max_threads =  DESK_MAX_TICKETS_THREADS
        self.max_tickets_search = DESK_MAX_TICKETS_SEARCH
        
        self.datetime_format = DESK_SEARCH_TICKETS_DATETIME_FORMAT

        self.session_request_count = session_request_count
        
        self._set_or_update_desk_requests_headers()
            
    def _get_token(self):
        """Private method to get the Bearer token to authenticate the requests"""
        auth_url = AUTH_BASE_URL + AUTH_TOKEN_ENDPOINT
        data = {
            'client_id': self._client_id, 
            'client_secret': self._client_secret, 
            'refresh_token': self._refresh_token,
            'grant_type': 'refresh_token'
        }
        try:
            # avoid recursive loop and nested try-except by not using self._request
            auth_resp = requests.post(auth_url, data = data)
            auth_resp_json = auth_resp.json()
        except Exception as e:
            traceback_message = '\n'.join(traceback.format_tb(e.__traceback__))
            raise ValueError(
                f'Unable to get Zoho Desk API access token due to the following error:\n'
                f'{traceback_message}\n{type(e).__name__}: {e}'
            )  
        else:
            self._token_expiration_time = time.time() + auth_resp_json.get('expires_in', DEFAULT_AUTH_TOKEN_EXPIRATION_TIME)
            return auth_resp_json['access_token']
        
    def _set_or_update_desk_requests_headers(self):
        """Helper method to construct the headers sent in each request"""
        token = self._get_token()
        self._zoho_desk_headers = {
            'Authorization': f'Zoho-oauthtoken {token}',
            'contentType': 'application/json; charset=utf-8',
        }
    
    def _handle_error(self, error, show_traceback = False):
        """Helper method that handles the errors potentially raised by `self._request`"""
        traceback_message = '\n'.join(traceback.format_tb(error.__traceback__)) + '\n' if show_traceback else ''
        error_message = f'{traceback_message}{type(error).__name__}: {error}'
        logger.error(error_message)
        raise error
    
    @refresh_token
    def _request(self, method, url, **kwargs):
        """Private method that sends API requests, and returns a Python dict"""
        self.session_request_count += 1
        
        try:
            res = requests.request(method, url, **kwargs)
            res.raise_for_status()
        except requests.HTTPError as http_e:
            self._handle_error(http_e)
        except Exception as e:
            self._handle_error(e, show_traceback = True)
        else:
            return res.json()
        
    def _get_all_data(self, url, verbose, log_msg, **request_params):
        """
        Helper method to repeatedly send requests to `url` and fetch
        all data that matches `request_params`. Its main use case is
        to easily retrieve data from endpoints that limit the response
        """
        n_calls = 0
        n_tickets_offset = request_params.get('from', 0)
        max_fetched = request_params['limit']
        
        data = []
        while True:
            if verbose:
                logger.info(f'{log_msg} that match the following criteria {request_params}')
                
            tmp_data = self._request('GET', url, headers = self._zoho_desk_headers, params = request_params)['data']
            data += tmp_data
            
            if len(tmp_data) < max_fetched:
                break
                
            n_calls += 1
            request_params.pop('from', 0)
            request_params = {**{'from': n_calls*max_fetched + n_tickets_offset}, **request_params}
            
        return data
   
    def get_ticket(self, ticket_id, fields = None, custom_fields = None, verbose = True, **request_params):
        """
        Uses '/api/v1/tickets/{ticket_id}' to retrieve the ticket whose id is `ticket_id`.
        See https://desk.zoho.com/support/APIDocument.do#Tickets_Getaticket for more info.
        
        Parameters
        ----------
        ticket_id: str
            id of the ticket
        fields: list, optional
            fields to include, among the returned by Zoho. set it to None to return
            them all
        custom_fields: list, optional
            fields to include, among the custom ones. set it to None to return
            all custom fields. this argument is only used if `fields` is None or includes 
            `customFields`
        verbose: bool, optional
            whether to print log messages when collecting data
        **request_params
            optional request params. see endpoint documentation for more info
            
        Return
        ------
        ticket: dict
            a dict containing the ticket info
        """
        url = DESK_BASE_URL + DESK_GET_TICKET_ENDPOINT.format(ticket_id = ticket_id)
        if verbose:
            logger.info(f'Getting ticket {ticket_id}')
        resp = self._request('GET', url, headers = self._zoho_desk_headers, params = request_params)
        
        if fields is not None:
            resp = {field: resp[field] for field in fields}
        if custom_fields is not None and 'customFields' in resp:
            resp['customFields'] = {field: resp['customFields'][field] for field in custom_fields}
            
        return resp
    
    def get_all_tickets(self, include_all = False, verbose = False, **request_params):
        """
        Uses '/api/v1/tickets' to list all tickets that match `request_params` criteria.
        See https://desk.zoho.com/support/APIDocument.do#Tickets_Listalltickets for more info.
        
        Parameters
        ----------
        include_all: bool, optional
            whether to include all tickets that match `request_params` or only those
            between [`from`, `from` + `limit`] (defined inside `request_params`)
        verbose: bool, optional
            whether to print log messages when collecting data. only used if 
            `include_all = True`
        **request_params
            optional request params. see endpoint documentation for more info
            
        Return
        ------
        tickets: list[dict]
            a list of dicts containing the tickets info
        """
        url = DESK_BASE_URL + DESK_GET_ALL_TICKETS_ENDPOINT
        request_params = {**{'limit': self.max_tickets}, **request_params}
        if include_all:
            return self._get_all_data(url, verbose = verbose, log_msg = 'Getting all tickets', **request_params)
        
        logger.info(f'Getting all tickets that satisfy {request_params}')
        return self._request('GET', url, headers = self._zoho_desk_headers, params = request_params)['data']
    
    def get_ticket_history(self, ticket_id, include_all = False, verbose = False, **request_params):
        """
        Uses '/api/v1/tickets/{ticket_id}/History' to get the history (details of all actions) of the
        ticket with id `ticket_id`.
        See https://desk.zoho.com/support/APIDocument.do#Tickets#Tickets_Gettickethistory for more info.
        
        Parameters
        ----------
        ticket_id: str
            id of the ticket
        include_all: bool, optional
            whether to include all events that match `request_params` or only those
            between [`from`, `from` + `limit`] (defined inside `request_params`)
        verbose: bool, optional
            whether to print log messages when collecting data. only used if 
            `include_all = True`
        **request_params
            optional request params. see endpoint documentation for more info
            
        Return
        ------
        events: list[dict]
            a list of dicts containing the events info
        """
        url = DESK_BASE_URL + DESK_GET_TICKET_HISTORY_ENDPOINT.format(ticket_id = ticket_id)
        request_params = {**{'limit': self.max_tickets_events}, **request_params}
        if include_all:
            return self._get_all_data(url, verbose = verbose, log_msg = f'Getting ticket {ticket_id} history', **request_params)
        
        logger.info(f'Getting ticket {ticket_id} history that match the following criteria {request_params}')
        return self._request('GET', url, headers = self._zoho_desk_headers, params = request_params)['data']
    
    def get_associated_tickets(self, include_all = False, verbose = False, **request_params):
        """
        Uses '/api/v1/associatedTickets' to get all associated tickets that match `request_params` criteria.
        See https://desk.zoho.com/support/APIDocument.do#Tickets#Tickets_Listallassociatedtickets for more info.
        
        Parameters
        ----------
        include_all: bool, optional
            whether to include all associated_tickets that match `request_params` or only those
            between [`from`, `from` + `limit`] (defined inside `request_params`)
        verbose: bool, optional
            whether to print log messages when collecting data. only used if 
            `include_all = True`
        **request_params
            optional request params. see endpoint documentation for more info
            
        Return
        ------
        associated_tickets: list[dict]
            a list of dicts containing the associated tickets info
        """
        url = DESK_BASE_URL + DESK_GET_ALL_ASSOCIATED_TICKETS_ENDPOINT
        request_params = {**{'limit': self.max_associated_tickets}, **request_params}
        if include_all:
            return self._get_all_data(url, verbose = verbose, log_msg = 'Getting associated tickets', **request_params)
                
        logger.info(f'Getting associated tickets that match the following criteria {request_params}')
        return self._request('GET', url, headers = self._zoho_desk_headers, params = request_params)['data']
    
    def update_ticket(self, ticket_id, update_data, verbose = True):
        """
        Uses '/api/v1/tickets/{ticket_id}' to update the ticket whose id is `ticket_id`, according to the given
        `update_data`. See https://desk.zoho.com/support/APIDocument.do#Tickets#Tickets_Updateaticket 
        for more info.
        
        Parameters
        ----------
        ticket_id: str
            id of the ticket
        update_data: dict
            request data used to update the ticket. see endpoint documentation for more info
        verbose: bool, optional
            whether to print log messages
            
        Returns
        -------
        updated_ticket: dict
            ticket updated with the new info
        """
        url = DESK_BASE_URL + DESK_UPDATE_TICKET_ENDPOINT.format(ticket_id = ticket_id)
        if verbose:
            logger.info(f'Updating ticket {ticket_id} with the following payload {update_data}')
        return self._request('PATCH', url, headers = self._zoho_desk_headers, data = json.dumps(update_data))
    
    def update_tickets(self, update_data, verbose = True):
        """
        Uses '/api/v1/tickets/updateMany' to update several tickets at once, with the same value and according
        to the given `update_data`. See https://desk.zoho.com/support/APIDocument.do#Tickets_Bulkupdatetickets
        for more info.
        
        Parameters
        ----------
        ticket_id: str
            id of the ticket
        update_data
            request data used to update the ticket. see endpoint documentation for more info
        verbose: bool, optional
            whether to print log messages
        """
        url = DESK_BASE_URL + DESK_BULK_UPDATE_TICKETS_ENDPOINT
        if verbose:
            logger.info(f'Updating multiple tickets according to the following payload {update_data}')
        return self._request('POST', url, headers = self._zoho_desk_headers, data = json.dumps(update_data))
    
    def search_tickets(self, include_all = True, verbose = True, **request_params):
        """
        Uses '/api/v1/tickets/search' to search for tickets. It allows both exact and wildcard search.
        See https://desk.zoho.com/support/APIDocument.do#Search#Search_TicketsSearchAPI for more info.
        
        Parameters
        ----------
        include_all: bool, optional
            whether to include all searched tickets that match `request_params` or only those
            between [`from`, `from` + `limit`] (defined inside `request_params`)
        verbose: bool, optional
            whether to print log messages when collecting data. only used if 
            `include_all = True`
        **request_params
            optional request params. see endpoint documentation for more info
            
        Return
        ------
        tickets: list[dict]
            a list of dicts containing the searched tickets info
        """
        url = DESK_BASE_URL + DESK_SEARCH_TICKETS_ENDPOINT
        request_params = {**{'limit': self.max_tickets_search}, **request_params}
        if include_all:
            return self._get_all_data(url, verbose = verbose, log_msg = 'Searching tickets', **request_params)
                
        logger.info(f'Searching tickets that match the following criteria {request_params}')
        return self._request('GET', url, headers = self._zoho_desk_headers, params = request_params)['data']
    
    def to_datetime(self, dt):
        """
        Helper function to format the given datetime `dt` object according to
        the Zoho Desk Tickets Search endpoint requirements
        """
        return dt.strftime(self.datetime_format)[:-3] + 'Z'
        
    def get_thread(self, ticket_id, thread_id, verbose = True, **request_params):
        """
        Uses '/api/v1/tickets/{ticket_id}/threads/{thread_id}' to fetch the thread `thread_id`, from the ticket
        `ticket_id`. See https://desk.zoho.com/support/APIDocument.do#Threads_Getathread for more info.
        
        Parameters
        ----------
        ticket_id: str
            id of the ticket
        thread_id: str
            id of the thread
        verbose: bool, optional
            whether to print log messages or not
        **request_params
            optional request params. see endpoint documentation for more info
        """
        url = DESK_BASE_URL + DESK_GET_THREAD_ENDPOINT.format(ticket_id = ticket_id, thread_id = thread_id)
        request_params = {**{'include': 'plainText'}, **request_params}
        if verbose:
            logger.info(f'Getting thread {thread_id} from ticket {ticket_id}')
        return self._request('GET', url, headers = self._zoho_desk_headers, params = request_params)
    
    def get_all_threads(self, ticket_id, include_all = True, verbose = True, **request_params):
        """
        Uses '/api/v1/tickets/{ticket_id}/threads' to fetch all threads related with the ticket`ticket_id`. 
        See https://desk.zoho.com/support/APIDocument.do#Threads_Listallthreads for more info.
        
        Parameters
        ----------
        ticket_id: str
            id of the ticket
        include_all: bool, optional
            whether to include all threads that match `request_params` or only those
            between [`from`, `from` + `limit`] (defined inside `request_params`)
        verbose: bool, optional
            whether to print log messages when collecting data. only used if 
            `include_all = True`
        **request_params
            optional request params. see endpoint documentation for more info
            
        Return
        ------
        threads: list[dict]
            a list of dicts containing the threads info
        """
        url = DESK_BASE_URL + DESK_GET_ALL_THREADS_ENDPOINT.format(ticket_id = ticket_id)
        request_params = {**{'limit': self.max_threads}, **request_params}
        if include_all:
            return self._get_all_data(
                url, 
                verbose = verbose, 
                log_msg = f'Getting all threads from ticket {ticket_id}', 
                **request_params
            )
                
        logger.info(f'Getting all threads from ticket {ticket_id} that satisfy {request_params}')
        return self._request('GET', url, headers = self._zoho_desk_headers, params = request_params)['data']
   
    def get_first_thread(self, ticket_id, verbose = True):
        """
        Uses `self.get_all_threads` and `self.get_thread`to fetch the thread corresponding to the first
        contact recorded in the ticket `ticket_id`.
        
        Parameters
        ----------
        ticket_id: str
            id of the ticket
        verbose: bool, optional
            whether to print log messages
        """
        if verbose:
            logger.info(f'Getting first thread from ticket {ticket_id}')
            
        threads = self.get_all_threads(ticket_id, include_all = True, verbose = False)    
        thread_id = threads[-1]['id']
        return self.get_thread(ticket_id, thread_id, verbose = False)
    
    def get_last_thread(self, ticket_id, verbose = True, **request_params):
        """
        Uses '/api/v1/tickets/{ticket_id}/latestThread' to fetch the most recent thread recorded in the ticket
        `ticket_id`. See https://desk.zoho.com/support/APIDocument.do#Threads_GetLatestthread for more info.
        
        Parameters
        ----------
        ticket_id: str
            id of the ticket
        verbose: bool, optional
            whether to print log messages
        **request_params
            optional request params. see endpoint documentation for more info
        """
        request_params = {**{'include': 'plainText'}, **request_params}
        url = DESK_BASE_URL + DESK_GET_LATEST_THREAD_ENDPOINT.format(ticket_id = ticket_id)
        if verbose:
            logger.info(f'Getting last thread from ticket {ticket_id}')
        return self._request('GET', url, headers = self._zoho_desk_headers, params = request_params)