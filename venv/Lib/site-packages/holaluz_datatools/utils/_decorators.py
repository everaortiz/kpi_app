import functools
import time
import logging
import re
import psutil
import inspect

logger = logging.getLogger(__name__)

def retry(func = None, *, exceptions = Exception, n_tries = 3, delay = 1, max_delay = 5, backoff = 1):
    """
    Decorator to re-execute a function `func` if it raises any error up to `n_tries` times.
    It can be used in either of the following ways
    ```
        @retry                                                                  # as a decorator
        def dummy():
            pass

        @retry()                                                                # as a decorator factory
        def dummy():
            pass

        @retry(exceptions = (CustomException1, CustomException2), n_tries = 4)  # as a decorator with arguments
        def dummy():
            pass
    ```
    Parameters
    ----------
    func:
        the decorated function. one must NOT pass this parameter, but it is
        needed for the decorator to accept optional parameters with no 
        parenthesis with its current construction
    exceptions: exception or tuple
        an exception or a tuple of exceptions to catch. default: Exception.
    n_tries: int
        the maximum number of attempts. default: 3.
    delay: int or float
        initial delay between attempts. default: 1
    max_delay: int or float
        maximum value of delay between attemps. default: 5
    backoff: int or float
        multiplier applied to delay between attempts. default: 1 (no backoff)
       
    Returns
    -------
    func:
        the decorated function
   
    Raises
    ------
    Exception
        the catched exception (one of `exeptions`), if it is still raised after
        `n_tries` attemps 
    """
    if func is None:
        kwargs = dict(exceptions=exceptions, n_tries=n_tries, delay=delay, max_delay=max_delay, backoff=backoff)
        return functools.partial(retry, **kwargs)

    @functools.wraps(func)
    def wrapper(*args, **kwargs):
        n = 1
        while n <= n_tries:
            try:
                return func(*args, **kwargs)
            except exceptions as e:
                err = e # store the error, just in case it need to be re-raised
                sleep_time = min(delay*(backoff**n), max_delay)
                logger_msg = (
                    f"execution of {func.__name__!r} failed on retry #{n} due to "
                    f"'{type(e).__name__}: {e}'; retrying in {sleep_time} seconds"
                )
                logger.warning(re.sub(r'\s+', ' ', logger_msg))
                time.sleep(sleep_time)
                n += 1
        logger.error(f"max retries reached during the execution of {func.__name__!r}.")
        raise err # re-raise the error, to recover its traceback
    return wrapper


def _elapsed_since(start, n_digits = 2):
    """helper function for the `profile ` decorator that computes and formats execution time"""
    elapsed = time.time() - start
    
    if elapsed < 1:
        return f'{round(elapsed*1000, n_digits)}ms'
    elif elapsed < 60:
        return f'{round(elapsed, n_digits)}s'
    elif elapsed < 3600:
        return f'{round(elapsed/60, n_digits)}min'
    else:
        return f'{round(elapsed/3600, n_digits)}h'

def _get_process_memory():
    """helper function for the `profile ` decorator that computes the memory usage"""

    process = psutil.Process() # get current pid
    mi = process.memory_info()
    
    # - RSS (Resident Set Size), which is the non-swapped physical memory
    #   a process has used; it matches “Mem Usage” column of taskmgr.exe
    # - VMS (Virtual Memory Size), that is the total amount of virtual memory
    #   used by the process; it is an alias for “VM Size” of taskmgr.exe
    return mi.rss, mi.vms

def _format_bytes(_bytes, n_digits = 2):
    """helper function for the `profile ` decorator that formats the used memory"""
    if abs(_bytes) < 1000:
        return f'{_bytes}B'
    elif abs(_bytes) < 1e6:
        return f'{round(_bytes/1e3, n_digits)}kB'
    elif abs(_bytes) < 1e9:
        return f'{round(_bytes/1e6, n_digits)}MB'
    else:
        return f'{round(_bytes/1e9, n_digits)}GB'

def profile(func = None, *args, log_level = logging.DEBUG, **kwargs):
    """
    performs the profiling of the given function `func`, i.e., computes
    the execution time and used memory, and logs the results in the
    level `log_level`
    """
    if func is None:
        return functools.partial(profile, *args, log_level = log_level, **kwargs)
    
    @functools.wraps(func)
    def wrapper(*args, **kwargs):
        rss_before, vms_before = _get_process_memory()
        start = time.time()
        result = func(*args, **kwargs)
        elapsed_time = _elapsed_since(start)
        rss_after, vms_after = _get_process_memory()
        
        log_msg = (
            'Profiling: <{func}>  RSS: {rss} | VMS: {vms} | time: {time}'.format(
                func = func.__name__,
                rss = _format_bytes(rss_after - rss_before),
                vms = _format_bytes(vms_after - vms_before),
                time = elapsed_time
            )
        )
        logger.log(log_level, log_msg)
        
        return result
    
    if inspect.isfunction(func):
        return wrapper
    elif inspect.ismethod(func):
        return wrapper(*args,**kwargs)


def compose(*decorators):
    """
    Decorator used to compose (concatenate) other decorators. Note that using
    ```
        @compose(dec_1, dec_2)
        func(*args, **kwargs)
    ```
    and using
    ```
        @dec_1
        @dec_2
        func(*args, **kwargs)
    ```
    yield equivalent results, as they both work as
    ```
        dec_1(dec_2(func(*args, **kwargs)))
    ```
    Its one and only use case is to shorten code (by having less linebreaks).
    It can handle both decorators with and without arguments, i.e.,
    ```
        @compose(dec_1(*args, **kwargs), dec_2(*args), dec_3(**kwargs), dec_4(), ..., dec_n)
        func(*args, **kwargs)
    ```
    """
    def wrapper(func):
        for dec in reversed(decorators):
            func = dec(func)
        return func
    return wrapper