import logging

DEFAULT_LOG_FORMAT = '[%(asctime)s] {%(filename)s} %(levelname)s: %(message)s'
LOGGERS_TO_SILENCE = {
    'botocore': logging.INFO,
    'boto3': logging.INFO,
    'snowflake': logging.WARNING,
    'requests': logging.WARNING,
    'urllib3': logging.WARNING,
    'slack_sdk': logging.WARNING,
    'report_client': logging.CRITICAL,
    'enhanced_report_client': logging.CRITICAL,
    'apiclient': logging.WARNING,
    'googleapiclient': logging.WARNING,
    'filelock': logging.WARNING
}

def set_logger_config(
    logger_level = logging.INFO, 
    log_format = DEFAULT_LOG_FORMAT, 
    date_format = None,
    loggers_to_silence = LOGGERS_TO_SILENCE
):
    """
    sets the log format for all loggers using `logging.basicConfig`,
    and also changes the level on the `loggers_to_silence` loggers,
    potentially to silence them but also to make them more verbose
    """
    # TODO add `logger_name` argument and format only the desired logger
    logging.basicConfig(format = log_format, datefmt = date_format, level = logger_level)

    # silence verbose loggers
    for logger_name, log_level in loggers_to_silence.items():
        logging.getLogger(logger_name).setLevel(log_level)

def add_logging_level(level_name, level_num, method_name = None):
    """
    Comprehensively adds a new logging level to the `logging` module and the
    currently configured logging class.

    `level_name` becomes an attribute of the `logging` module with the value
    `level_num`. `method_name` becomes a convenience method for both `logging`
    itself and the class returned by `logging.getLoggerClass()` (usually just
    `logging.Logger`). If `method_name` is not specified, `level_name.lower()`
    is used.

    To avoid accidental clobberings of existing attributes, this method will
    raise an `AttributeError` if the level name is already an attribute of the
    `logging` module or if the method name is already present 

    Example
    -------
    >>> add_logging_level('TRACE', logging.DEBUG - 5)
    >>> logging.getLogger(__name__).setLevel("TRACE")
    >>> logging.getLogger(__name__).trace('that worked')
    >>> logging.trace('so did this')
    >>> logging.TRACE
    5

    """
    if not method_name:
        method_name = level_name.lower()

    if hasattr(logging, level_name):
        raise AttributeError('{} already defined in logging module'.format(level_name))
    if hasattr(logging, method_name):
        raise AttributeError('{} already defined in logging module'.format(method_name))
    if hasattr(logging.getLoggerClass(), method_name):
        raise AttributeError('{} already defined in logger class'.format(method_name))
        
    def log_for_level(self, message, *args, **kwargs):
        if self.isEnabledFor(level_num):
            self._log(level_num, message, args, **kwargs)
    def log_to_root(message, *args, **kwargs):
        logging.log(level_num, message, *args, **kwargs)

    logging.addLevelName(level_num, level_name)
    setattr(logging, level_name, level_num)
    setattr(logging.getLoggerClass(), method_name, log_for_level)
    setattr(logging, method_name, log_to_root)
