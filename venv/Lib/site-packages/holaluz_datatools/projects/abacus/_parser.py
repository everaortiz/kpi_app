import os
import configparser
import re
import logging

from ._params import *

logger = logging.getLogger(__name__)

class Metric(configparser.ConfigParser):
    """
    Dummy class based on `configparser.ConfigParser` in which we 
    define the metric objects
    """
    def __repr__(self):
        return 'Empty metric' if not self.sections() else f'Metric with sections {self.sections()}'

class MetricParser:
    """
    Parser for the metric files, i.e., helper class to write and
    read them.
    """
    def __init__(self, mode = DEFAULT_MODE, local_path = None, files_extension = None, **metric_kwargs):
        """
        Parameters
        ----------
        mode: str, optional
            whether to use the wrapper to interact with
                - the BI Metrics page (if `mode = 'metrics'`)
                - the BI Alerts page (if `mode = 'alerts'`)
        local_path: str, optional
            path where the metric files are located. if not given,
            it uses the default according to `MODE2PAGE_DATA_MAP`
            and `mode`
        files_extension: str, optional
            default metric files extensions. if not given,it uses 
            the default according to `MODE2PAGE_DATA_MAP`and `mode`
        **metric_kwargs
            further keyword arguments forwarded to
            the Metric class
        """
        if mode not in MODE_ACCEPTED_VALUES:
            raise ValueError(f'mode must be one of {MODE_ACCEPTED_VALUES}')

        self.local_path = local_path or MODE2PAGE_DATA_MAP[mode]['local_path']
        self.files_extension = files_extension or MODE2PAGE_DATA_MAP[mode]['files_extension']
        self.operation = MODE2PAGE_DATA_MAP[mode]['operation']
        self.metric_kwargs = metric_kwargs
    
    def _format_metric_name(self, metric_file_name):
        """prettifies the metric file name"""
        return metric_file_name.replace('_', ' ').capitalize()
    
    def _format_metric_file_name(self, metric_name):
        """converts the metric name into its corresponding file name"""
        return metric_name.replace(' ', '_').lower()
    
    def _check_user_input(self, sql_flavour, credentials_key):
        assert credentials_key in ACCEPTED_CREDS_KEYS,\
            f'invalid credentials key; it must be one of {ACCEPTED_CREDS_KEYS}'

        assert sql_flavour in ACCEPTED_SQL_FLAVOURS,\
            f'invalid SQL flavour; it must be one of {ACCEPTED_SQL_FLAVOURS}'

    def write_metric_file(
        self, 
        sql_query, 
        sql_flavour, 
        metric_name, 
        metric_description, 
        team, 
        credentials_key, 
        local_path = None,
        **metric_kwargs
    ):
        """
        Writes (creates or replaces) a metric file
        
        Parameters
        ----------
        sql_query: str
            query to compute the metric
        sql_flavour: str
            SQL flavour 
        metric_name: str
            metric file name 
        metric_description: str
            the metric description, it will be displayed in the 
            corresponding Notion page
        team: str
            the team that has created the metric 
        credentials_key: str
            the key of the credentials to load when computing the
            metric
        local_path: str, optional
            the path where the metric file is created. if not given,
            it uses `self.local_path`
        **metric_kwargs
            further keyword arguments forwarded to the `Metric` class. 
            if not given, it uses `self.metric_kwargs`
        """
        self._check_user_input(sql_flavour, credentials_key)
        local_path = local_path or self.local_path
    
        metric_kwargs = {**self.metric_kwargs, **metric_kwargs}
        metric = Metric(**metric_kwargs)
        metric[metric_name] = {
            'flavour': sql_flavour, 
            'query': sql_query,
            'name': self._format_metric_name(metric_name),
            'description': metric_description,
            'team': team,
            'credentials_key': credentials_key if credentials_key is not None else ''
        }

        metric_filename = f'{self._format_metric_file_name(metric_name)}.{self.files_extension}'
        logger.info(
                f'writing {self.operation} {self._format_metric_name(metric_name)!r} '
                f'in file {metric_filename!r}'
            )
        with open(os.path.join(local_path, metric_filename), 'w') as fout:
            metric.write(fout)
    
    def get_metric_data(self, metric):
        """
        Gets the data of the given metric and returns it as a dictionary
        
        Parameters
        ----------
        metric: Metric or dict
            the metric whose data needs to be extracted
        """
        if isinstance(metric, Metric):
            return {section: {k: v for k, v in metric[section].items()} for section in metric.sections()}
        else:
            return metric
    
    def read_metric_file(self, metric_name, local_path = None, **metric_kwargs):
        """
        Reads a metric file and returns its data as a dict
        
        Parameters
        ----------
        metric_name: str
            metric name or file name 
        local_path: str, optional
            the path where the metric file is located. if not given, 
            it uses `self.local_path`
        **metric_kwargs
            further keyword arguments forwarded to the `Metricp  class. 
            if not given, it uses `self.metric_kwargs`
            
        Returns
        -------
        metric_data: dict
        """
        local_path = local_path or self.local_path
        
        metric_kwargs = {**self.metric_kwargs, **metric_kwargs}
        metric = Metric(**metric_kwargs)
        
        metric_name = metric_name if not metric_name.endswith(self.files_extension) else metric_name.split('.')[0]
        metric_filename = f'{self._format_metric_file_name(metric_name)}.{self.files_extension}'
        
        logger.info(
            f'reading {self.operation} {self._format_metric_name(metric_name)!r} '
            f'from file {metric_filename!r}'
        )
        metric.read(os.path.join(local_path, metric_filename))
        return self.get_metric_data(metric)

    def read_metric_files(self, local_path = None, pattern = None):
        """
        Reads all (matching) metric file  in the folder `metric_path` 
        and returns them as a list of dicts
        
        Parameters
        ----------
        local_path: str, optional
            the path where the metric files are stored. if not given, 
            it uses `self.local_path`
        pattern: str, optional
            regex pattern to filter the read metrics. if not given, 
            it reads all metric files in `local_path`
            
        Returns
        -------
        metric_data: dict
        """
        local_path = local_path or self.local_path

        metric_files = os.listdir(local_path)
        if pattern is not None:
            metric_files = [metric_file for metric_file in metric_files if re.match(pattern, metric_file)]

        return (self.read_metric_file(metric_file, local_path) for metric_file in metric_files)