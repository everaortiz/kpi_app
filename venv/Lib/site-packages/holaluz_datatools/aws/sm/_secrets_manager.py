import os
import logging
import json
import boto3

try:
    uname = os.uname()
except AttributeError:
    # `os` does not have the `uname` attribute for windows instances,
    # and in these we want to use the generic role by now
    ASSUMED_ROLE = 'arn:aws:iam::334068498838:role/AdminRole'
else:
    # otherwise, we are in a Linux instance, which can only be kate
    # at the moment
    ASSUMED_ROLE = 'arn:aws:iam::334068498838:role/kate-bi'

REGION_NAME = "eu-west-1"

SESSION_ROLE_NAME = 'bi-secrets-check'
SESSION_DURATION = 3600

MAX_RESULTS_PER_PAGE = 100

logger = logging.getLogger(__name__)

class SecretStructureError(Exception):
    """
    Custom exception raised when one tries to add a key 
    to a non-nested dict secret
    """
    ...
    
class SecretKeyError(Exception):
    """
    Custom exception raised when one tries to add a key 
    to a non-nested dict secret
    """
    ...

class SecretsManagerResource:
    """
    High-level wrapper around the boto3 secrets manager client
    to easily create, modify and get info from the secrets
    stored in the AWS Secrets Manager service.
    """
    def __init__(self, access_key = None, secret_key = None):
        """
        Creates the underlying boto3 secrets manager client,
        which assumes the default role `self._assumed_role`
        
        For more information about the client creation see
        `self.login`
        
        Parameters
        ----------
        access_key: str, optional
            the AWS APIs access key
        secret_key: str, optional
            the AWS APIs secret key
        """
        self._region_name = REGION_NAME
        self._assumed_role = ASSUMED_ROLE
        self._session_role_name = SESSION_ROLE_NAME
        self._session_duration_seconds = SESSION_DURATION
        
        self._max_results_per_page = MAX_RESULTS_PER_PAGE
        
        self.inner_client = self.login(access_key, secret_key)
        
    def __enter__(self):
        return self
    
    def __exit__(self, exc_type, exc_value, traceback):
        pass
        
    def login(self, access_key = None, secret_key = None):
        """
        Creates the underlying boto3 secrets manager client,
        which assumes the default role `self._assumed_role`
        
        If no credentials are given, i.e., both are None, it
        falls back to boto3 default behaviour, meaning that  
        it gets the credentials from the AWS CLI shared folder
        `~/.aws`
        
        Parameters
        ----------
        access_key: str, optional
            the AWS APIs access key
        secret_key: str, optional
            the AWS APIs secret key
            
        Returns
        -------
        secrets_manager_client: boto3.client
        """
        # loads the credentials from the AWS shared folder `~/.aws`
        sts_client = boto3.client(
            service_name = 'sts',
            aws_access_key_id = access_key,
            aws_secret_access_key = secret_key,
            region_name = self._region_name
        )

        assumed_role_object = sts_client.assume_role(
            RoleArn = self._assumed_role,
            RoleSessionName = self._session_role_name,
            DurationSeconds = self._session_duration_seconds
        )

        session = boto3.session.Session(
            aws_access_key_id = assumed_role_object['Credentials']['AccessKeyId'],
            aws_secret_access_key = assumed_role_object['Credentials']['SecretAccessKey'],
            aws_session_token = assumed_role_object['Credentials']['SessionToken']
        )

        return session.client(
            service_name = 'secretsmanager',
        )
    
    def create_secret(
        self, 
        secret_name, 
        secret_string, 
        description = '', 
        tags = [], 
        force_overwrite = False
    ):
        """
        Creates and stores a new secret within the current session
        
        Parameters
        ----------
        secret_name: str
            name of the new secret 
        secret_string: str
            JSON-formatted text data that contains the secrets to store
        description: str, optional
            description of the secret
        tags: list[dict], optional
            list of dict representing the secrets tags. each tag dict
            must be formatted as follows
                {'Key': '<tag_name>', 'Value': '<tag_value>'}
        force_overwrite: bool, optional
            whether to deletion and creation of a new secret with the
            same name
        
        Usage example
        -------------
        The minimum required:
        ```
            simple_secrets = {'user': 'data_analytics', 'password': '123456aa'}
            resource.create_secret(
                secret_name = 'simple-secret',
                secret_string = json.dumps(simple_secrets)
            )
        ```
        
        A complete example:
        ```
            nested_secrets = {
                'secret_1': {
                    'user': 'data_analytics', 
                    'password': '123456aa'
                },
                'secret_2': {
                    'access_key': 'ASBYSA15AH', 
                    'secret_key': 'BASUIGA1827216283BKJSAK...'
                },
                'secret_3': {
                    'api_token': 'bsayuvhasshb1715373bdchd'
                }
            }
            secrets_tags = [
                {'Key': 'enviroment', 'Value': 'test'},
                {'Key': 'dummy_key', 'Value': 'dummy_value'},
            ]
            resource.create_secret(
                secret_name = 'nested-secret',
                secret_string = json.dumps(nested_secrets),
                description = 'Just some nested secrets, as a demo',
                tags = secrets_tags,
                force_overwrite = False
            )
        ```
        """
        return self.inner_client.create_secret(
            Name = secret_name,
            SecretString = secret_string,
            Description = description,
            Tags = tags,
            ForceOverwriteReplicaSecret = force_overwrite
        )
    
    def delete_secret(self, secret_name, force_deletion = None, recovery_window = None):
        """
        Deletes a secret and all of its versions. You can specify a recovery window
        during which you can restore the secret. The default recovery window is 30 days. 

        Parameters
        ----------
        secret_name: str
            name of the new secret 
        force_deletion: str
            whether to delete the secret without any recovery window
        recovery_window: str, optional
            number of days from 7 to 30 that Secrets Manager waits before permanently deleting the secret
        """
        payload = {'SecretId': secret_name}
        if force_deletion is not None:
            payload['ForceDeleteWithoutRecovery'] = force_deletion
        if recovery_window is not None:
            payload['RecoveryWindowInDays'] = recovery_window

        return self.inner_client.delete_secret(**payload)

    def describe_secret(self, secret_name):
        """
        Retrieves all populated fields of the secret a but the encrypted ones, 
        i.e., the secret string.
        
        Parameters
        ----------
        secret_name: str
            name of the secret 
        """
        return self.inner_client.describe_secret(SecretId = secret_name)
        
    def _get_secret(self, secret_name, secret_version_id = None):
        """
        Retrieves the contents of the encrypted field ``SecretString``
        from the specified version of a secret.
        
        Parameters
        ----------
        secret_name: str
            name of the secret 
        secret_version_id: str, optional
            id of the secret version. defaults to the latest        
        """
        kwargs = {'SecretId': secret_name}
        if secret_version_id is not None:
            kwargs.update({'VersionId': secret_version_id})

        return self.inner_client.get_secret_value(**kwargs)
    
    def get_secret(self, secret_name, secret_version_id = None):
        """
        Retrieves the contents of the encrypted field ``SecretString``
        from the specified version of a secret.
        
        Parameters
        ----------
        secret_name: str
            name of the secret 
        secret_version_id: str, optional
            id of the secret version. defaults to the latest
            
        Return
        ------
        secret: dict
            JSON-formatted secret string loaded into a dict        
        """
        secret = self._get_secret(secret_name, secret_version_id)
        return json.loads(secret['SecretString'])
    
    def _list_secrets(self, filters, next_token = None):
        """
        Lists the secrets accessible with the current session
        
        Parameters
        ----------
        filters: list[dict], optional
            list of dict representing the filters. each filter dict
            must be formatted as follows
                {'Key': '<filter_name>', 'Value': ['<filter_value>']},
            and the Key accepted values are 'description', 'name', 
            'tag-key', 'tag-value', 'primary-region'.
            note that one can prefix the search value with an 
            exclamation mark (`!`) to perform negation filters 
        next_token: str, optional
            if igiven, pass the `NextToken` to the underlying secrets
            manager client to retrieve the corresponding secrets.  
        """
        kwargs = {
            'Filters': filters,
            'MaxResults': self._max_results_per_page
        }
        if next_token is not None:
            kwargs.update({'NextToken': next_token})
            
        return self.inner_client.list_secrets(**kwargs)
        
    def list_secrets(self, filters = [], paginate_all = True):
        """
        Lists the secrets accessible with the current session
        
        Parameters
        ----------
        filters: list[dict], optional
            list of dict representing the filters. each filter dict
            must be formatted as follows
                {'Key': '<filter_name>', 'Value': ['<filter_value>']},
            and the Key accepted values are 'description', 'name', 
            'tag-key', 'tag-value', 'primary-region'.
            note that one can prefix the search value with an 
            exclamation mark (`!`) to perform negation filters 
        paginate_all: bool, optional
            whether to paginate over all secrets to return a complete
            list or just the secrets in the first request
            
        Returns
        -------
        secrets_manager_client: boto3.client
        
        Usage example
        -------------
        ```
            filters = [
                {'Key': 'description', 'Values': ['just a sample description']}
            ]
            resource.list_secrets(filters = filters, paginate_all = True)
        ```
        """
        secrets = self._list_secrets(filters)
        secrets_list = secrets['SecretList']
        
        while paginate_all and 'NextToken' in secrets:
            secrets = self._list_secrets(filters, secrets['NextToken'])
            secrets_list += secrets['SecretList']

        return secrets_list
    
    @property
    def secrets_list(self):
        """Lists of all secrets accessible with the current session"""
        return self.list_secrets()
    
    def _list_secret_versions(self, secret_name, next_token = None):
        """
        Lists the secret versions accessible with the current session
        
        Parameters
        ----------
        filters: list[dict], optional
            list of dict representing the filters. each filter dict
            must be formatted as follows
                {'Key': '<filter_name>', 'Value': ['<filter_value>']},
            and the Key accepted values are 'description', 'name', 
            'tag-key', 'tag-value', 'primary-region'.
            
            note that one cap prefix the search value with an 
            exclamation mark (`!`) to perform negation filters 
        next_token: str, optional
            if igiven, pass the `NextToken` to the underlying secrets
            manager client to retrieve the corresponding secrets. 
        """
        kwargs = {
            'SecretId': secret_name,
            'MaxResults': self._max_results_per_page
        }
        if next_token is not None:
            kwargs.update({'NextToken': next_token})
            
        return self.inner_client.list_secret_version_ids(**kwargs)
        
    def list_secret_versions(self, secret_name, paginate_all = True):
        """
        Lists the secret versions accessible with the current session
        
        Parameters
        ----------
        filters: list[dict], optional
            list of dict representing the filters. each filter dict
            must be formatted as follows
                {'Key': '<filter_name>', 'Value': ['<filter_value>']},
            and the Key accepted values are 'description', 'name', 
            'tag-key', 'tag-value', 'primary-region'.
            
            note that one cap prefix the search value with an 
            exclamation mark (`!`) to perform negation filters 
        paginate_all: bool, optional
            whether to paginate over all secrets to return a complete
            list or just the secrets in the first request
            
        Returns
        -------
        secrets_manager_client: boto3.client
        
        Usage example
        -------------
        ```
            filters = [
                {'Key': 'description', 'Values': ['just a sample description']}
            ]
            resource.list_secrets(filters = filters, paginate_all = True)
        ```
        """
        versions = self._list_secret_version_ids(secret_name)
        versions_list = versions['Versions']
        
        while paginate_all and 'NextToken' in versions:
            versions = self._list_secret_version_ids(secret_name, versions['NextToken'])
            versions_list += versions['Versions']

        return versions_list
        
    def update_secret(self, secret_name, secret_string, description = None):
        """
        Updates an existing secret accessible within the current session
        
        Parameters
        ----------
        secret_name: str
            name of the new secret 
        secret_string: str
            JSON-formatted text data that contains the secrets to store
        description: str, optional
            description of the secret
        
        Usage example
        -------------
        The minimum required:
        ```
            simple_secrets = {'user': 'data_analytics', 'password': '123456aa'}
            resource.update_secret(
                secret_name = 'simple-secret',
                secret_string = json.dumps(simple_secrets)
            )
        ```
        """
        kwargs = {
            'SecretId': secret_name,
            'SecretString': secret_string,
        }
        if description is not None:
            kwargs.update({'Description': description})
            
        return self.inner_client.update_secret(**kwargs)
    
    def _check_secret_integrity(
        self, 
        secret,
        secret_name,
        secret_new_key, 
        overwrite_existing_key = False
    ):
        """
        helper method to check the secret integrity and determine
        if a new pair (key, value) can be added
        """
        if not isinstance(secret, dict):
            sse = SecretStructureError(
                f'Unable to add {secret_new_key!r} to the secret {secret_name!r}: '
                f'expected `secret` to be a {dict}, but {type(secret)} was passed'
            )
            logger.error(f'{sse.__class__.__name__}: {sse}')
            raise sse
            
        if not all(isinstance(v, dict) for v in secret.values()):
            sse = SecretStructureError(
                f'Unable to add {secret_new_key!r} to the secret {secret_name!r}: '
                f'cannot add a new key to a non-nested secret'
            )
            logger.error(f'{sse.__class__.__name__}: {sse}')
            raise sse

        if not overwrite_existing_key and secret_new_key in secret:
            ske = SecretKeyError(
                f'Unable to add {secret_new_key!r} to the secret {secret_name!r}: '
                f'key {secret_new_key!r} already exists in the given secret, '
                f'to overwrite it set `overwrite_existing_key = True`'
            )
            logger.error(f'{ske.__class__.__name__}: {ske}')
            raise ske
        
    def add_key_to_secret(
        self, 
        secret_name, 
        secret_key, 
        secret_value,
        overwrite_existing_key = False,
        secret_version_id = None
    ):
        """
        Adds a new pair {secret_key: secret_value} to an existing secret `secret_name`
        accessible within the current session
        
        Parameters
        ----------
        secret_name: str
            name of the existing secret 
        secret_key: str
            key of the secret part
        secret_value: dict
            value of the new secret part
        overwrite_existing_key: bool, optional
            whether to allow to overwrite `secret_key` if it already exists in `secret_name`
        secret_version_id: str, optional
            id of the secret version. defaults to the latest

        Raises
        ------
        SecretStructureError
            if the secret associated to `secret_name` is not a nested JSON-formatted
            dict
        SecretKeyError
            if the key `secret_key` already exists in the secret `secret_name` and
            `overwrite_existing_key = False`
        
        """
        secret = self.get_secret(secret_name, secret_version_id)
        self._check_secret_integrity(
            secret, 
            secret_name, 
            secret_key, 
            overwrite_existing_key
        )
        
        # update and sort
        secret.update({secret_key: secret_value})
        return self.update_secret(
            secret_name, 
            json.dumps({k: secret[k] for k in sorted(secret)})
        )
