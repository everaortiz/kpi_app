import datetime
import logging

DEFAULT_OVERLAP_INTERVAL = {'seconds': 0}

# according to our folder structure and schedule interval,
# we should not have an overlap exceeding this value
MAX_OVERLAP_INTERVAL = {'days': 1}


logger = logging.getLogger(__name__)

def generate_report_temporal_bounds(date, schedule_interval, overlap_interval = DEFAULT_OVERLAP_INTERVAL):
    """
    Helper function to generate the time interval with which we generate the reports.
    
    Parameters
    ----------
    date: datetime.datetime
        base date with which we compute the bounds
    schedule_interval: dict
        dict with which we generate a datetime.timedelta for the
        report to contain data according to the Airflow execution
        interval
    overlap_interval: dict, optional
        dict with which we generate a datetime.timedelta to force 
        data overlap within executions
    
    Returns
    -------
    dt_from: datetime.datetime
        initial time of the report temporal interval
    dt_to: datetime.datetime
        final time of the interval
    """
    schedule_timedelta = datetime.timedelta(**schedule_interval)
    max_timedelta = datetime.timedelta(**MAX_OVERLAP_INTERVAL)
    if schedule_timedelta > max_timedelta:
        raise ValueError(
            f'`schedule_interval` cannot exceed {max_timedelta}, '
            f'but {schedule_timedelta} was given'
        )
    
    overlap_timedelta = datetime.timedelta(**overlap_interval)
    if overlap_timedelta > max_timedelta:
        logger.warning(
            f'`overlap_interval` cannot exceed {max_timedelta}, '
            f'but {overlap_timedelta} was given. clipping it to '
            f'its maximum accepted value'
        )
    total_timedelta = schedule_timedelta + overlap_timedelta
    
    # do not left out the last generated data of the day,
    # which is extracted on the first execution of the 
    # following day, regardless of the schedule interval
    if (date - schedule_timedelta).date() < date.date():
        dt_to = date.replace(hour = 0, minute = 0, second = 0)
        dt_from = max(
            dt_to - max_timedelta,
            dt_to - total_timedelta
        )
    else:
        dt_to = date.replace(second = 0, microsecond = 0)
        dt_from = max(
            dt_to.replace(hour = 0, minute = 0),
            dt_to - total_timedelta
        )
        
    return dt_from, dt_to