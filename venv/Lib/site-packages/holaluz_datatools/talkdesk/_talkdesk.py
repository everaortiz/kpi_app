import logging
import json
import io
import re
import pandas as pd
import base64
import time
import requests

from ._decorators import use_defaults, refresh_token, check_report_type


ACCOUNT_NAME = 'holaluz'
URL_AUTHENTICATION_ENDPOINT = "https://{account_name}.talkdeskid.eu/oauth/token" # POST
URL_APIS_BASE = 'https://api.talkdeskapp.eu'

# NOTE: the check report status is useless ATM, as it
#       returns the report content
ENDPOINT_DOWNLOAD_REPORT = 'data/reports/{type}/files/{id}'                      # GET
ENDPOINT_LIST_REPORTS_BY_TYPE = 'data/reports/{type}/jobs'                       # GET
ENDPOINT_EXECUTE_REPORT = 'data/reports/{type}/jobs'                             # POST
ENDPOINT_DELETE_REPORT = 'data/reports/{type}/files/{id}'                        # DELETE

CLIENT_CREDENTIALS_GRAND_TYPE = 'client_credentials'
REFRESH_TOKEN_GRAND_TYPE = 'refresh_token'
JWT_EXPIRATION_TIME = 300 # seconds
TOKEN_EXPIRATION_BUFFER = 10 # seconds

SCOPES = [
    'data-reports:read',
    'data-reports:write'
]

DEFAULT_REPORT_FORMAT = 'csv'
DEFAULT_TIME_ZONE = 'Europe/Madrid'
DEFAULT_DATETIME_FORMAT = '%Y-%m-%dT%H:%M:%S'

RETRY_DELAY = 5
RETRY_MAX_DELAY = 30
RETY_BACKOFF = 2

ACCEPTED_REPORT_TYPES = [
    'acw_time_data', 'adherence', 'calls', 'contact_online_time', 'contacts', 'csat_score', 
    'explore_calls',  'feedback', 'hold_time_data', 'inbound_contact_volume', 'outbound_dialer_calls',
    'qm_evaluation_analysis', 'qm_evaluation_score', 'qm_interaction_details', 'ring_attempts',
    'studio_flow_execution', 'talk_time_data', 'user_status'
]

logger = logging.getLogger(__name__)

def compute_sleep_time(try_n, delay = RETRY_DELAY, max_delay = RETRY_MAX_DELAY, backoff = RETY_BACKOFF):
    """Helper function that computes the sleep time between requests using and exponential backoff algorithm"""
    return min(delay*(backoff**try_n), max_delay)

class ReportCreationTimeoutError(Exception):
    """Custom exception raised when a report is not available before the mas creation time"""
    ...
    
class TalkdeskClient:
    def __init__(
        self, 
        client_id,
        client_secret, 
        account_name = ACCOUNT_NAME,
        scopes = SCOPES,
    ):

        self._client_id = client_id
        self._client_secret = client_secret
                
        self._account_name = account_name
        self._auth_url = URL_AUTHENTICATION_ENDPOINT.format(account_name = account_name)
        self._scopes = scopes     
        
        self._generate_auth_token()

    def __enter__(self):
        return self
    
    def __exit__(self, exc_type, exc_value, traceback):
        # nothing to do here, as there is no connection to close
        # because we interact with the AWS cli API
        pass
    
    def _handle_error(self, error, log_error, show_traceback):
        if log_error:                
            error_message = f'{type(error).__name__}: {error}'
            if isinstance(error, requests.HTTPError):
                try:
                    additional_info = json.dumps(error.response.json())
                except json.JSONDecodeError:
                    additional_info = re.sub(r'\s+', ' ', error.response.text)
                finally:    
                    error_message += f'\nError additional information: {additional_info}'
                
            logger.error(error_message, exc_info = show_traceback)
            
        raise error

    def _request(self, method, url, **kwargs):
        log_error = kwargs.pop('log_error', True)
        
        try:
            response = requests.request(method, url, **kwargs)
            response.raise_for_status()
        except requests.HTTPError as http_e:
            self._handle_error(http_e, log_error = log_error, show_traceback = False)
        except Exception as e:
            self._handle_error(e, log_error = log_error, show_traceback = True)
        else:
            try:
                return response.json()
            except json.JSONDecodeError as json_e:
                # returning response.text may result in incorrect decoded characters,
                # as response uses Latin-1 as default encoding, but the API response
                # is encoded using utf-8
                return response.content.decode()
    
    @use_defaults
    def _generate_auth_token(
        self, 
        _client_id = None, 
        _client_secret = None, 
        _scopes = None,
        _auth_type = None
    ):
        token = base64.b64encode(f'{_client_id}:{_client_secret}'.encode()).decode('utf-8')
        headers = {
            'Accept': 'application/json',
            'Authorization': f'Basic {token}',
            'Content-Type': 'application/x-www-form-urlencoded'
        }
        
        payload = {
            'grant_type': CLIENT_CREDENTIALS_GRAND_TYPE,
        }                          
        if _scopes:
            payload['scope'] = ' '.join(_scopes) if isinstance(_scopes, list) else _scopes
        
        json_response = self._request(
            method = 'POST', 
            url = self._auth_url, 
            data = payload, 
            headers = headers
        )
        
        self._auth_token_expiration_time = (
            time.time() + json_response['expires_in'] - TOKEN_EXPIRATION_BUFFER
        )
        self._auth_token = json_response['access_token']
        self._auth_data = json_response
    
    def _get_api_uri(self, endpoint, base_url = URL_APIS_BASE, **endpoint_ftm_kwargs):
        if endpoint_ftm_kwargs:
            endpoint = endpoint.format(**endpoint_ftm_kwargs)
            
        return f'{base_url}/{endpoint}'
    
    @refresh_token
    def _get_request_headers(self):
        return {
            'Accept': 'application/json', 
            'Authorization': f'Bearer {self._auth_token}'            
        }
    
    @check_report_type
    def execute_report(
        self, 
        report_type, 
        dt_from, 
        dt_to, 
        report_format = DEFAULT_REPORT_FORMAT, 
        timezone = DEFAULT_TIME_ZONE, 
        report_name = None,
        verbose = True,
        **kwargs
    ):
        url = self._get_api_uri(
            ENDPOINT_EXECUTE_REPORT, 
            type = report_type
        )
        payload = {
            'name': report_name,
            'timezone': timezone,
            'format': report_format,
            'timespan': {
                'from': dt_from.strftime(DEFAULT_DATETIME_FORMAT),
                'to': dt_to.strftime(DEFAULT_DATETIME_FORMAT)
            }
        }
        
        if verbose:
            logger.info(
                f'creating {report_type!r} report with the following params {payload}'
            )
        
        return self._request(
            method = 'POST', 
            url = url,
            json = payload,
            headers = self._get_request_headers(),
            **kwargs
        )
        
    @check_report_type
    def download_report(self, report_type, report_id, verbose = True, **kwargs):
        url = self._get_api_uri(
            ENDPOINT_DOWNLOAD_REPORT, 
            type = report_type, 
            id = report_id
        )
        
        if verbose:
            logger.info(
                f'downloading {report_type!r} report with id = {report_id!r}'
            )
        
        return self._request(
            method = 'GET', 
            url = url, 
            headers = self._get_request_headers(),
            **kwargs
        )
    
    @check_report_type
    def list_reports(
        self, 
        report_type, 
        page = 1, 
        per_page = 20, 
        paginate_all = True,
        statuses_to_exclude = ['deleted'],
        verbose = True,
        **kwargs
    ):
        url = self._get_api_uri(
            ENDPOINT_LIST_REPORTS_BY_TYPE, 
            type = report_type
        )
        params = {'page': page, 'per_page': per_page}
        
        if verbose:
            if paginate_all:
                log_msg = f'listing all reports of type {report_type!r}'
            else:
                log_msg = f'listing reports of type {report_type!r} with the following params {params}'
                
            if statuses_to_exclude:
                log_msg += f', excluding those whose is status is in {statuses_to_exclude}'
                
            logger.info(log_msg)
        
        data =  self._request(
            method = 'GET', 
            url = url,
            headers = self._get_request_headers(),
            params = params,
            **kwargs
        )
        reports = data['_embedded']['jobs']
            
        if paginate_all:
            while 'next' in data['_links']:
                data =  self._request(
                    method = 'GET', 
                    url = data['_links']['next']['href'],
                    headers = self._get_request_headers(),
                    **kwargs
                )
                reports += data['_embedded']['jobs']
        
        if statuses_to_exclude: # 'done', 'processing', 'queued', 'created', 'deleted'
            reports = [
                report for report in reports if report['status'] not in statuses_to_exclude
            ]
            
        return reports
    
    @check_report_type
    def delete_report(self, report_type, report_id, verbose = True):
        url = self._get_api_uri(
            ENDPOINT_DELETE_REPORT, 
            type = report_type, 
            id = report_id
        )
        
        if verbose:
            logger.info(
                f'deleting {report_type!r} report with id = {report_id!r}'
            )
        
        return self._request(
            method = 'DELETE', 
            url = url,
            headers = self._get_request_headers(),
        )
    
    def _try_get_report_data(self, report_type, report_id, max_retries = 5, verbose = True):
        for i in range(max_retries):
            if verbose:
                logger.info(
                    f'getting the report {report_id!r} data '
                    f'(attempt {i + 1} of {max_retries})'
                )
            
            try:
                # we use the download endpoint because the check status one
                # also returns the report data, instead of some metadata
                # including the status
                return self.download_report(
                    report_type, 
                    report_id, 
                    verbose = False, 
                    log_error = False
                )
            except requests.HTTPError as http_e:
                if http_e.response.status_code != 404:
                    raise
                time.sleep(compute_sleep_time(i))
        else:
            raise ReportCreationTimeoutError(
                f'unable to download {report_type!r} report with id = {report_id!r}. '
                f'check again later'
            )
    
    def _process_report_data(self, report_data, report_id, report_format, raw_report):
        logger.info(f'processing report {report_id!r} data into a dataframe')
        
        if report_format == 'csv':
            # CSV-formatted reports are returned as string,
            # which we pass a buffered stream
            df = pd.read_csv(io.StringIO(report_data), sep = ',', header = 0)
        else: 
            # JSON-formatted reports are returned as dicts
            df = pd.DataFrame(report_data['entries'])
        
        if raw_report:
            return df

        # format column names
        return df.rename(columns = lambda x: re.sub(r'[\s+\.]', '_', x).lower())
    
    def get_new_report(self, report_type, dt_from, dt_to, raw_report = False, **kwargs):
        report_metadata = self.execute_report(report_type, dt_from, dt_to, **kwargs)
        
        report_id = report_metadata['job']['id']
        report_format = report_metadata['job']['format']
        
        return self._process_report_data(
            report_data = self._try_get_report_data(report_type, report_id),
            report_id = report_id,
            report_format = report_format,
            raw_report = raw_report
        ) 
    
    def get_report_metadata_by_idx(self, report_type, report_idx):
        return self.list_reports(report_type, verbose = False)[report_idx]
    
    def get_report_by_idx(self, report_type, report_idx, raw_report = False):
        report_metadata = self.get_report_metadata_by_idx(report_type, report_idx)
        
        report_id = report_metadata['id']
        report_format = report_metadata['format']      
        
        return self._process_report_data(
            report_data = self._try_get_report_data(report_type, report_id),
            report_id = report_id,
            report_format = report_format,
            raw_report = raw_report
        )
    
    def delete_reports(self, report_type, older_than, verbose = True):      
        if verbose:
            if older_than is None:
                log_msg = f'deleting all {report_type!r} reports'
            else:
                log_msg =  f'deleting {report_type!r} reports created before {older_than}'
            logger.info(log_msg)
               
        reports = self.list_reports(report_type, verbose = False)
        for report in reports:
            created_at = pd.to_datetime(report['created_at'], format = DEFAULT_DATETIME_FORMAT)
            if older_than is None or older_than > created_at:
                self.delete_report(report_type, report['id'], verbose = False)
